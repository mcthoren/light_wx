#!/usr/bin/python3
# -*- coding: UTF-8 -*-

import time, datetime, busio, board, sys, fileinput, os, argparse
import numpy as np
import matplotlib.dates as mdates
import adafruit_veml6070
import adafruit_tsl2561

sys.path.append('/home/ghz/wxlib')
import wxlib as wx

wx_dir = "/home/ghz/light_wx"
plot_d = wx_dir+'/plots/'
dat_fname='light_levels'

def conv_qs(data):
	if data == b'??' or data == '??':
		return np.nan
	else:
		return data

# this is, in the end, coverting utf-8 data to utf-8 data, cuz somewhere it got thought of as bytes.
def u2u(data):
	return mdates.strpdate2num('%Y%m%d%H%M%S')(data.decode("utf8"))

def plot(ts, n_plate):
	npoints = 2085 # about 3 days in reality
	dat_f = ["1000", "0100", "0010", "0001"]
	td = datetime.datetime.strptime(ts, "%Y%m%d%H%M%S")

	for i in range(0, 4):
		d_date = (td - datetime.timedelta(i)).strftime("%Y%m%d")
		d_year = (td - datetime.timedelta(i)).strftime("%Y")
		dat_f[3 - i] = wx_dir+'/data/'+d_year+'/'+n_plate+'.'+d_date
		wx.proof_dat_f(dat_f[3 - i])

	light_dat  = fileinput.input(dat_f)

	date, lux, uva, bb, ir , pt = np.loadtxt(light_dat, usecols=(0, 2, 4, 6, 8, 12), unpack=True,  \
		converters={ 0: u2u, 2: conv_qs, 4: conv_qs, 6: conv_qs, 8: conv_qs, 12: conv_qs})

	if date.size < 4:
		return 0 # not enough points yet. wait for more

	if date.size < npoints:
		npoints = date.size - 1

	f_pts  = date.size - npoints
	t_pts  = date.size

	wx.graph(date[f_pts : t_pts], lux[f_pts : t_pts], "y-", "Illuminance", "Illuminance (lx)", plot_d+'light_lux.png')
	wx.graph(date[f_pts : t_pts], uva[f_pts : t_pts], "b-", "UVA Illuminance", "Illuminance (counts)", plot_d+'light_uva.png')
	wx.graph(date[f_pts : t_pts], bb[f_pts : t_pts], "g-", "Broad Band Illuminance", "Illuminance (counts)", plot_d+'light_bb.png')
	wx.graph(date[f_pts : t_pts], ir[f_pts : t_pts], "r-", "IR Illuminance", "Illuminance (counts)", plot_d+'light_ir.png')
	wx.graph(date[f_pts : t_pts], pt[f_pts : t_pts], "c-", "Pi Temp", "Temp Â°C", plot_d+'light_temp.png')

# part of the ongoing effort to keeps the two sensors from locking up when it's bright out.
def uv_read(uv):
	if(uv == 0):
		return np.nan

	uv.wake()

	# we get 0 if we don't wait first.
	time.sleep(0.9)

	# first reads are kinda bogus after wake.
	uvr = uv.uv_raw
	uvr = uv.uv_raw
	uvr = uv.uv_raw
	uv.sleep()
	return uvr

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Record, graph, and upload ambient light levels.')
	parser.add_argument('-d', dest = 'debug', action = 'store_true', help='turn on debug chars')
	parser.add_argument('-D', dest = 'moredebug', action = 'store_true', help='turn on more debug chars')
	parser.add_argument('-k', dest = 'killuv', action = 'store_true', help='kill the uv sensor')
	args = parser.parse_args()

	i2c = busio.I2C(board.SCL, board.SDA)

	# the adafruit lib will take the following integration times
	# https://learn.adafruit.com/adafruit-veml6070-uv-light-sensor-breakout?view=all
	# VEML6070_HALF_T	~62.5ms
	# VEML6070_1_T		~125ms
	# VEML6070_2_T		~250ms
	# VEML6070_4_T		~500ms
	uv_int_tarray = [62.5, 125, 250, 500]
	uv_dings_array = ['VEML6070_HALF_T', 'VEML6070_1_T', 'VEML6070_2_T', 'VEML6070_4_T']
	uv_a_idx = 0
	uv_int_time = uv_dings_array[uv_a_idx]

	# sometimes our uv sensor goes away, and only powering it off for a minute or two
	# and restarting it will bring it back, which is hard to do remotely. tmep hack.
	if(args.killuv):
		uv_sens = 0
	else:
		uv_sens = adafruit_veml6070.VEML6070(i2c, uv_int_time)

	vis_ir = adafruit_tsl2561.TSL2561(i2c)

	# integration time (0 = 13.7ms, 1 = 101ms, 2 = 402ms)
	int_time = 0

	wx.proof_dir(plot_d)

	# init the tsl sensor
	vis_ir.enabled = True
	time.sleep(1)
	vis_ir.gain = 0
	vis_ir.integration_time = int_time

	# first reads are often kinda bogus
	try:
		if(args.debug):
			print('$', end='', flush=True)

		lux = vis_ir.lux
		bb = vis_ir.broadband
		ir = vis_ir.infrared
	except:
		print("inital read failed.")
		exit()

	vis_ir.enabled = False

	t_vals = {}
	vals = {}
	counts = {}
	for i in range(0,5):
		t_vals[i] = vals[i] = counts[i] = 0

	while True:

		uvt = uv_read(uv_sens)
		if(isinstance(uvt, (float, int))):
			if(uvt < 1.0 and uv_a_idx < 3):
				if(args.debug):
					print('^', end='', flush=True)
				uv_a_idx += 1
				uv_sens.integration_time = uv_dings_array[uv_a_idx]
			if(uvt > 100 and uv_a_idx > 0):
				if(args.debug):
					print('v', end='', flush=True)
				uv_a_idx -= 1
				uv_sens.integration_time = uv_dings_array[uv_a_idx]

		t_vals[1] = uv_read(uv_sens)

		vis_ir.enabled = True

		# we get bogus values in the dark if we don't wait a bit first
		time.sleep(0.5)

		# run a couple reads after wake up to shake the sleep out.
		t_vals[0] = vis_ir.lux
		time.sleep(0.1)
		t_vals[0] = vis_ir.lux
		time.sleep(0.1)
		t_vals[0] = vis_ir.lux

		gain = vis_ir.gain
		int_time = vis_ir.integration_time
		bbt = vis_ir.broadband
		irt = vis_ir.infrared

		if(args.moredebug):
			print("(", gain, ",", int_time, ")->", end='', flush=True)

		if(isinstance(gain, (float, int)) and isinstance(bbt, (float, int)) and isinstance(irt, (float, int))):
			if(bbt < 4.0 and irt < 2.0):
				if(gain < 0.5):
					vis_ir.gain = 1
				if(gain > 0.5):
					if(int_time < 2):
						int_time += 1
						if(args.debug):
							print('+', end='', flush=True)
						vis_ir.integration_time = int_time

			if(bbt > 100 and irt > 100):
				if(gain > 0.5):
					vis_ir.gain = 0
				if(gain < 0.5):
					if(int_time > 0):
						int_time -= 1
						if(args.debug):
							print('-', end='', flush=True)
						vis_ir.integration_time = int_time

		if(args.moredebug):
			print("(", gain, ",", int_time, ")", end='', flush=True)

		gain = vis_ir.gain			# we might have just changed this, recheck it.
		if(isinstance(gain, (float, int))):	# we don't always get types that make sense.
			if(gain > 0.5):
				t_vals[2] = vis_ir.broadband / 16.0
				t_vals[3] = vis_ir.infrared / 16.0
			else:
				t_vals[2] = vis_ir.broadband
				t_vals[3] = vis_ir.infrared

		# do the last lux read with the final gain setting
		t_vals[0] = vis_ir.lux
		vis_ir.enabled = False

		t_vals[4] = float(wx.pi_temp_read()) / 1000

		for i in range(0,5):
			if(isinstance(t_vals[i], (float, int))):
				vals[i] += t_vals[i]
				counts[i] += 1

		if(args.debug):
			print('.', end='', flush=True)

		# wait till we have at least 64 counts for one of the more reliable sensors.
		if(counts[4] >= 64 or counts[1] >= 64):

			# XXX div by 0 workaround for wonky lux part.
			if(vals[0] == 0 and counts[0] == 0):
				if(args.debug):
					print('!', end='', flush=True)
				counts[0] = np.nan

			try:
				dbg_step = 0
				lux = "%.2f" % (vals[0] / counts[0])
				dbg_step = 1
				tuvr = (vals[1] / counts[1])
				dbg_step = 2
				tbb = (vals[2] / counts[2])
				dbg_step = 3
				tir = (vals[3] / counts[3])
				dbg_step = 4
				pi_t = "%.2f" % (vals[4] / counts[4])
				dbg_step = 5
			except:
				# this can (and does) happen if z.B. we never get a valid count for the lux
				# toss everything and start main loop over again.
				print("computing averages failed: ", dbg_step)
				if(args.debug):
					print("t_vals: ", t_vals)
					print("vals: ", vals)
					print("counts: ", counts, flush=True)

				for i in range(0,5):
					t_vals[i] = vals[i] = counts[i] = 0

				continue

			if(args.debug):
				print('*', end='', flush=True)

			# scaling here appears linear with integration time, unlike in the lux calc???
			if(int_time == 0):
				tbb *= 402/13.7
				tir *= 402/13.7

			if(int_time == 1):
				tbb *= 402/101
				tir *= 402/101

			# scaling for uv integration time
			tuvr *= 500 / uv_int_tarray[uv_a_idx]

			# if the lux model inputs are 0, we can resonably expect 0 on the output
			if(vals[2] == 0 and vals[3] == 0):
				if(args.debug):
					print('_', end='', flush=True)
				lux = 0.00

			# it's gotten better, but we still get some wobbles in the lux calc.
			if(tbb > 5000 and tir > 5000 and float(lux) < 10):
				if(args.debug):
					print('#', end='', flush=True)
				lux = np.nan

			bb = "%.2f" % (tbb)
			ir = "%.2f" % (tir)
			uvr = "%.2f" % (tuvr)
			ts = datetime.datetime.fromtimestamp(time.time()).strftime("%Y%m%d%H%M%S")
			dat = "%s\tlux: %s\tUVA: %s\tBB: %s\tIR: %s\tGain: %s\tPi_temp: %s\tvis_int_time: %s\tuv_int_time: %s\n" % \
				 (ts, lux, uvr, bb, ir, gain, pi_t, int_time, uv_dings_array[uv_a_idx])
			wx.write_out_dat_stamp(ts, dat_fname, dat, wx_dir)

			# it's solar powered. i'm in n.eu. it doesn't always enjoy clean shutdowns,
			# and then garbage in the dat file prevents the graphing from working on restart.
			# try a sync, and see if that helps. how much garbage should we write to a closed file?
			os.sync()

			plot(ts, dat_fname)

			if(args.debug):
				print('r', end='', flush=True)

			try:
				# wx7_sync defined in ~/.ssh/config with host, user, key, etc.
				os.system('/usr/bin/rsync --timeout=60 -ur ' + wx_dir + '/* wx7_sync:/wx7/')
			except:
				print("rsync failed.")

			if(args.debug):
				print(counts, flush=True)

			for i in range(0,5):
				t_vals[i] = vals[i] = counts[i] = 0
