#!/usr/bin/python3
# -*- coding: UTF-8 -*-

import time, datetime, busio, board, sys, fileinput, os, argparse
import numpy as np
import matplotlib.dates as mdates
import adafruit_veml6070
import adafruit_tsl2561

sys.path.append('/home/ghz/wxlib')
import wxlib as wx

wx_dir = "/home/ghz/light_wx"
plot_d = wx_dir+'/plots/'
dat_fname='light_levels'

def conv_qs(data):
	if data == b'??' or data == '??':
		return np.nan
	else:
		return data

# this is, in the end, coverting utf-8 data to utf-8 data, cuz somewhere it got thought of as bytes.
def u2u(data):
	return mdates.strpdate2num('%Y%m%d%H%M%S')(data.decode("utf8"))

def plot(ts, n_plate):
	npoints = 2085 # about 3 days in reality
	dat_f = ["1000", "0100", "0010", "0001"]
	td = datetime.datetime.strptime(ts, "%Y%m%d%H%M%S")

	for i in range(0, 4):
		d_date = (td - datetime.timedelta(i)).strftime("%Y%m%d")
		d_year = (td - datetime.timedelta(i)).strftime("%Y")
		dat_f[3 - i] = wx_dir+'/data/'+d_year+'/'+n_plate+'.'+d_date
		wx.proof_dat_f(dat_f[3 - i])

	light_dat  = fileinput.input(dat_f)

	date, lux, uva, bb, ir , pt = np.loadtxt(light_dat, usecols=(0, 2, 4, 6, 8, 12), unpack=True,  \
		converters={ 0: u2u, 2: conv_qs, 4: conv_qs, 6: conv_qs, 8: conv_qs, 12: conv_qs})

	if date.size < 4:
		return 0 # not enough points yet. wait for more

	if date.size < npoints:
		npoints = date.size - 1

	f_pts  = date.size - npoints
	t_pts  = date.size

	wx.graph(date[f_pts : t_pts], lux[f_pts : t_pts], "y-", "Approximate Illuminance", "Approximate Illuminance (lx)", plot_d+'light_lux.png')
	wx.graph(date[f_pts : t_pts], uva[f_pts : t_pts], "b-", "UVA Illuminance", "Illuminance (counts)", plot_d+'light_uva.png')
	wx.graph(date[f_pts : t_pts], bb[f_pts : t_pts], "g-", "Broad Band Illuminance", "Illuminance (counts)", plot_d+'light_bb.png')
	wx.graph(date[f_pts : t_pts], ir[f_pts : t_pts], "r-", "IR Illuminance", "Illuminance (counts)", plot_d+'light_ir.png')
	wx.graph(date[f_pts : t_pts], pt[f_pts : t_pts], "c-", "Pi Temp", "Temp Â°C", plot_d+'light_temp.png')

# part of the ongoing effort to keeps the two sensors from locking up when it's bright out.
def uv_read(uv):
	uv.wake()

	# we get 0 if we don't wait first.
	time.sleep(0.9)

	# first reads are kinda bogus after wake.
	uvr = uv.uv_raw
	uvr = uv.uv_raw
	uvr = uv.uv_raw
	uv.sleep()
	return uvr

# altough the library we use seems to implement the lux calculation exactly as
# specified on page 23 of the datasheet here:
# https://cdn-shop.adafruit.com/datasheets/TSL2561.pdf, the returned values in
# bright weather are clearly bullshit. reimplement ourselves so we can fight
# with it and try to work out what's going on.
def lux_calc(ch0, ch1, gain, int_time):
	# bb := broadband is ch0
	# ir := infrared is ch1

	lux = np.nan

	if(args.debug):
		ch0_str = "%.2f" % ch0
		ch1_str = "%.2f" % ch1

	# div0
	if(ch0 == 0):
		if(args.debug):
			print("div0 ch0:", ch0_str, "ch1:", ch1_str, end='', flush=True)
		return np.nan

	# nominal for the data sheet is 16x gain and 402ms integration time
	# so if gain is off we need to adjust for it
	# datasheet pages 24, 26 and 27
	if(gain < 0.5):
		ch0 *= 16
		ch1 *= 16

	# if integration time is "0" (13.7ms) or "1" (101ms) we need the following "scale factors"
	# data sheet pages 26 and 27
	if(int_time == 0):
		ch0 *= 322/11
		ch1 *= 322/11

	if(int_time == 1):
		ch0 *= 322/81
		ch1 *= 322/81

	ch1_ch0 = ch1 / ch0

	if(ch1_ch0 > 0 and ch1_ch0 <= 0.5):
		lux = 0.0304 * ch0 - 0.062 * ((ch1_ch0) ** 1.4) * ch0
		if(args.debug):
			print("0 ch0:", ch0_str, "ch1:", ch1_str, end='', flush=True)

	if(ch1_ch0 > 0.5 and ch1_ch0 <= 0.61):
		lux = 0.0224 * ch0 - 0.031 * ch1
		if(args.debug):
			print("1 ch0:", ch0_str, "ch1:", ch1_str, end='', flush=True)

	if(ch1_ch0 > 0.61 and ch1_ch0 <= 0.80):
		lux = 0.0128 * ch0 - 0.0153 * ch1
		if(args.debug):
			print("2 ch0:", ch0_str, "ch1:", ch1_str, end='', flush=True)

	if(ch1_ch0 > 0.8 and ch1_ch0 <= 1.3):
		lux = 0.00146 * ch0 - 0.00112 * ch1
		if(args.debug):
			print("3 ch0:", ch0_str, "ch1:", ch1_str, end='', flush=True)

	if(ch1_ch0 > 1.3 and ch1_ch0 <= 1.6):
		# lux = np.nan
		# the model in the datasheet sucks. it's known to suck. and in bright cloudy weather it is obviously wrong.
		# so we're going to stat screwing with it
		lux = 0.00146 * ch0 - 0.0009125 * ch1
		if(args.debug):
			print("4 ch0:", ch0_str, "ch1:", ch1_str, end='', flush=True)
	if(ch1_ch0 > 1.6):
		# lux = np.nan
		lux = 0.0001 * ch0
		if(args.debug):
			print("5 ch0:", ch0_str, "ch1:", ch1_str, end='', flush=True)

	return lux

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Record, graph, and upload ambient light levels.')
	parser.add_argument('-d', dest = 'debug', action = 'store_true', help='turn on debug chars')
	args = parser.parse_args()

	i2c = busio.I2C(board.SCL, board.SDA)

	uv_sens = adafruit_veml6070.VEML6070(i2c, 'VEML6070_2_T')
	vis_ir = adafruit_tsl2561.TSL2561(i2c)

	# integration time (0 = 13.7ms, 1 = 101ms, 2 = 402ms)
	int_time = 0

	wx.proof_dir(plot_d)

	# init the tsl sensor
	vis_ir.enabled = True
	time.sleep(1)
	vis_ir.gain = 0
	vis_ir.integration_time = int_time

	# first reads are often kinda bogus
	try:
		if(args.debug):
			print('+', end='', flush=True)

		lux = vis_ir.lux
		bb = vis_ir.broadband
		ir = vis_ir.infrared
	except:
		print("inital read failed.")
		exit()

	t_vals = {}
	vals = {}
	counts = {}
	for i in range(0,5):
		t_vals[i] = vals[i] = counts[i] = 0

	while True:

		t_vals[1] = uv_read(uv_sens)

		vis_ir.enabled = True

		# we get bogus values in the dark if we don't wait a bit first
		time.sleep(0.5)

		t_vals[0] = vis_ir.lux
		time.sleep(0.1)
		t_vals[0] = vis_ir.lux
		time.sleep(0.1)
		t_vals[0] = vis_ir.lux

		gain = vis_ir.gain
		bbt = vis_ir.broadband
		if isinstance(gain, (float, int)) and isinstance(bbt, (float, int)):
			if bbt <= 10 and gain < 0.5:
				vis_ir.gain = 1
			if bbt >= 1000 and gain > 0.5:
				vis_ir.gain = 0

		gain = vis_ir.gain			# we might have just changed this, recheck it.
		if isinstance(gain, (float, int)):	# we don't always get types that make sense.
			if gain > 0.5:
				t_vals[2] = vis_ir.broadband / 16.0
				t_vals[3] = vis_ir.infrared / 16.0
			else:
				t_vals[2] = vis_ir.broadband
				t_vals[3] = vis_ir.infrared

		vis_ir.enabled = False
		t_vals[4] = float(wx.pi_temp_read()) / 1000

		for i in range(0,5):
			if isinstance(t_vals[i], (float, int)):
				vals[i] += t_vals[i]
				counts[i] += 1

		if(args.debug):
			print('.', end='', flush=True)

		# wait till we have at least 64 counts for one of the more reliable sensors.
		if(counts[4] >= 64 or counts[1] >= 64):

			# XXX div by 0 workaround for wonky lux part.
			if(vals[0] == 0 and counts[0] == 0):
				if(args.debug):
					print('!', end='', flush=True)
				counts[0] = np.nan

			try:
				dbg_step = 0
				lux = "%.2f" % (vals[0] / counts[0])
				dbg_step = 1
				uvr = "%.2f" % (vals[1] / counts[1])
				dbg_step = 2
				bb = "%.2f" % (vals[2] / counts[2])
				dbg_step = 3
				ir = "%.2f" % (vals[3] / counts[3])
				dbg_step = 4
				pi_t = "%.2f" % (vals[4] / counts[4])
				dbg_step = 5
				clux = "%.2f" % lux_calc((vals[2] / counts[2]), (vals[3] / counts[3]), gain, int_time)
				dbg_step = 6
				if(args.debug):
					print(" %", clux, "|", lux, "% ", end='', flush=True)
				dbg_step = 7
			except:
				# this can (and does) happen if z.B. we never get a valid count for the lux
				# toss everything and start main loop over again.
				print("computing averages failed: ", dbg_step)
				if(args.debug):
					print("t_vals: ", t_vals)
					print("vals: ", vals)
					print("counts: ", counts, flush=True)

				for i in range(0,5):
					t_vals[i] = vals[i] = counts[i] = 0

				continue

			if(args.debug):
				print('*', end='', flush=True)

			lux = clux
			ts = datetime.datetime.fromtimestamp(time.time()).strftime("%Y%m%d%H%M%S")
			dat = "%s\tlux: %s\tUVA: %s\tBB: %s\tIR: %s\tGain: %s\tPi_temp: %s\n" % (ts, lux, uvr, bb, ir, gain, pi_t)
			wx.write_out_dat_stamp(ts, dat_fname, dat, wx_dir)
			plot(ts, dat_fname)

			if(args.debug):
				print('r', end='', flush=True)

			try:
				# wx7_sync defined in ~/.ssh/config with host, user, key, etc.
				os.system('/usr/bin/rsync --timeout=60 -ur ' + wx_dir + '/* wx7_sync:/wx7/')
			except:
				print("rsync failed.")

			if(args.debug):
				print(counts, flush=True)

			for i in range(0,5):
				t_vals[i] = vals[i] = counts[i] = 0
