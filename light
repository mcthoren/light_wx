#!/usr/bin/python3
# -*- coding: UTF-8 -*-

import time, datetime, busio, board, sys, fileinput, os, argparse
import numpy as np
import matplotlib.dates as mdates
import adafruit_veml6070
import adafruit_tsl2561

sys.path.append('/home/ghz/wxlib')
import wxlib as wx

wx_dir = "/home/ghz/light_wx"
plot_d = wx_dir+'/plots/'
dat_fname='light_levels'

def conv_qs(data):
	if data == b'??' or data == '??':
		return 0.0
	else:
		return data

# this is, in the end, coverting utf-8 data to utf-8 data, cuz somewhere it got thought of as bytes.
def u2u(data):
	return mdates.strpdate2num('%Y%m%d%H%M%S')(data.decode("utf8"))

def plot(ts, n_plate):
	npoints = 2085 # about 3 days in reality
	dat_f = ["1000", "0100", "0010", "0001"]
	td = datetime.datetime.strptime(ts, "%Y%m%d%H%M%S")

	for i in range(0, 4):
		d_date = (td - datetime.timedelta(i)).strftime("%Y%m%d")
		d_year = (td - datetime.timedelta(i)).strftime("%Y")
		dat_f[3 - i] = wx_dir+'/data/'+d_year+'/'+n_plate+'.'+d_date
		wx.proof_dat_f(dat_f[3 - i])

	light_dat  = fileinput.input(dat_f)

	date, lux, uva, bb, ir , pt = np.loadtxt(light_dat, usecols=(0, 2, 4, 6, 8, 12), unpack=True,  \
		converters={ 0: u2u, 2: conv_qs, 4: conv_qs, 6: conv_qs, 8: conv_qs, 12: conv_qs})

	if date.size < 4:
		return 0; # not enough points yet. wait for more

	if date.size < npoints:
		npoints = date.size - 1

	f_pts  = date.size - npoints
	t_pts  = date.size

	wx.graph(date[f_pts : t_pts], lux[f_pts : t_pts], "y-", "Illuminance", "Illuminance (lx)", plot_d+'light_lux.png')
	wx.graph(date[f_pts : t_pts], uva[f_pts : t_pts], "b-", "UVA Illuminance", "Illuminance (counts)", plot_d+'light_uva.png')
	wx.graph(date[f_pts : t_pts], bb[f_pts : t_pts], "g-", "Broad Band Illuminance", "Illuminance (counts)", plot_d+'light_bb.png')
	wx.graph(date[f_pts : t_pts], ir[f_pts : t_pts], "r-", "IR Illuminance", "Illuminance (counts)", plot_d+'light_ir.png')
	wx.graph(date[f_pts : t_pts], pt[f_pts : t_pts], "c-", "Pi Temp", "Temp Â°C", plot_d+'light_temp.png')

# part of the ongoing effort to keeps the two sensors from locking up when it's bright out.
def uv_read(uv):
	uv.wake()

	# we get 0 if we don't wait first.
	time.sleep(0.9)

	# first reads are kinda bogus after wake.
	uvr = uv.uv_raw
	uvr = uv.uv_raw
	uvr = uv.uv_raw
	uv.sleep()
	return uvr

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Record, graph, and upload ambient light levels.')
	parser.add_argument('-d', dest = 'debug', action = 'store_true', help='turn on debug chars')
	args = parser.parse_args()

	i2c = busio.I2C(board.SCL, board.SDA)

	uv_sens = adafruit_veml6070.VEML6070(i2c, 'VEML6070_4_T')
	vis_ir = adafruit_tsl2561.TSL2561(i2c)

	wx.proof_dir(plot_d)

	# init the tsl sensor
	vis_ir.enabled = True
	time.sleep(1)
	vis_ir.gain = 0
	vis_ir.integration_time = 1

	# first reads are often kinda bogus
	try:
		if(args.debug):
			print('+', end='', flush=True)

		lux = vis_ir.lux
		bb = vis_ir.broadband
		ir = vis_ir.infrared
	except:
		print("inital read failed.")
		exit()

	t_vals = {}
	vals = {}
	counts = {}
	for i in range(0,5):
		t_vals[i] = vals[i] = counts[i] = 0

	time0 = time1 = time.time()

	while True:

		t_vals[1] = uv_read(uv_sens)

		vis_ir.enabled = True

		# we get bogus values in the dark if we don't wait a bit first
		time.sleep(0.5)

		t_vals[0] = vis_ir.lux
		t_vals[0] = vis_ir.lux
		t_vals[0] = vis_ir.lux

		gain = vis_ir.gain
		bbt = vis_ir.broadband
		if isinstance(gain, (float, int)) and isinstance(bbt, (float, int)):
			if bbt <= 10 and gain < 0.5:
				vis_ir.gain = 1
			if bbt >= 1000 and gain > 0.5:
				vis_ir.gain = 0

		gain = vis_ir.gain			# we might have just changed this, recheck it.
		if isinstance(gain, (float, int)):	# we don't always get types that make sense.
			if gain > 0.5:
				t_vals[2] = vis_ir.broadband / 16.0
				t_vals[3] = vis_ir.infrared / 16.0
			else:
				t_vals[2] = vis_ir.broadband
				t_vals[3] = vis_ir.infrared

		vis_ir.enabled = False
		t_vals[4] = float(wx.pi_temp_read()) / 1000

		for i in range(0,5):
			if isinstance(t_vals[i], (float, int)):
				vals[i] += t_vals[i]
				counts[i] += 1

		if(args.debug):
			print('.', end='', flush=True)

		time1 = time.time()
		if((time1 - time0) > 60):

			try:
				dbg_step = 0
				lux = "%.2f" % (vals[0] / counts[0])
				dbg_step = 1
				uvr = "%d" % (vals[1] / counts[1])
				dbg_step = 2
				bb = "%d" % (vals[2] / counts[2])
				dbg_step = 3
				ir = "%d" % (vals[3] / counts[3])
				dbg_step = 4
				pi_t = "%.2f" % (vals[4] / counts[4])
				dbg_step = 5
			except:
				# this can happen if z.B. we never get a valid count for the lux
				# toss everything and start main loop over again.
				print("computing averages failed: ", dbg_step)
				if(args.debug):
					print("vals: ", vals)
					print("counts: ", counts)
				time0 = time1 = time.time()
				for i in range(0,5):
					t_vals[i] = vals[i] = counts[i] = 0
				continue

			if(args.debug):
				print('*', end='', flush=True)

			ts = datetime.datetime.fromtimestamp(time.time()).strftime("%Y%m%d%H%M%S")
			dat = "%s\tlux: %s\tUVA: %s\tBB: %s\tIR: %s\tGain: %s\tPi_temp: %s\n" % (ts, lux, uvr, bb, ir, gain, pi_t)
			wx.write_out_dat_stamp(ts, dat_fname, dat, wx_dir)
			plot(ts, dat_fname)

			if(args.debug):
				print('r', end='', flush=True)

			try:
				# wx7_sync defined in ~/.ssh/config with host, user, key, etc.
				os.system('/usr/bin/rsync --timeout=60 -ur ' + wx_dir + '/* wx7_sync:/wx7/')
			except:
				print("rsync failed.")

			if(args.debug):
				print(counts, end='', flush=True)

			time0 = time1 = time.time()
			for i in range(0,5):
				t_vals[i] = vals[i] = counts[i] = 0
